package registrar

import (
	"fmt"
	"log"
	"strings"

	Logger "../logger"
	"golang.org/x/crypto/bcrypt"
)

// Registrar holds information related to the registry
type Registrar struct {
	Registry      map[string]map[uint]AppInfo
	Logpath       string
	Logfile       string
	LogInfoCh     chan Logger.Info
	LogShutdownCh chan bool
}

// AppInfo is primary data structure used by registrar and application to exchange information
//  about the service they provide.
type AppInfo struct {
	Host          string // "localhost"
	Port          string // "8888"
	Name          string // service name, all workers providing same service will have same Name
	Version       string // service version, all workers providing same service will have same Name
	AppID         uint   // generated by registrar upon registration, unique for each workers and service
	Secret        string // secret session token will be used by service
	ReqestHandled uint64
	RequestMade   uint64
	// we should not use Go dependent complex type such as time as we will require to receive these param from other systems
}

// Registry is map of map. Outer map will take Service Name as Key and inner map will take AppID as key.
// AppID will be generated by registrar

// func initMaps() {
// 	// if WorkerCount == nil {
// 	// 	WorkerCount = make(map[string]uint)
// 	// }
// 	if Registry == nil {
// 		Registry = make(map[string]map[uint]AppInfo)
// 	}
// }

func generateID() func() uint {
	id := uint(0)
	return func() uint {
		id++
		return id
	}
}

var nextAppID func() uint

// Register will add appData in registry and will return modified appData
func (registrar *Registrar) Register(appName string, appData AppInfo) AppInfo {
	if nextAppID == nil {
		nextAppID = generateID()
	}
	//initMaps()
	//WorkerCount[appName]++
	appData.AppID = nextAppID() // WorkerCount[appName]

	if registrar.Registry[appName] == nil {
		registrar.Registry[appName] = map[uint]AppInfo{}
	}
	registrar.Registry[appName][appData.AppID] = appData
	return appData
}

// UnRegister will un-register and remove the entry of appData and will return appData
func (registrar *Registrar) UnRegister(appName string, appID uint) AppInfo {
	//initMaps()
	appData, found := registrar.Registry[appName][appID]
	if !found {
		return AppInfo{}
	}
	delete(registrar.Registry[appName], appID)
	return appData
}

func urlPathProcessing(path string) []string {
	if path == "" {
		return []string{}
	}
	if path == "/" {
		return []string{"/"}
	}
	return strings.Split(path, "/")[1:]
}

// HelloRegistrar says Hello
func (registrar *Registrar) HelloRegistrar() {
	fmt.Println("Hello from registrar")

	// path := "/favicon.ico"
	// path1 := "/inventory/list/all"
	// path2 := "/inventory/list/all?key1=value1&key2=value2"
	// fmt.Println("Spliting: ", path)
	// for i, v := range strings.Split(path, "/") {
	// 	fmt.Println("\t", i, v)
	// }

	// fmt.Println("Spliting: ", path1)
	// for i, v := range strings.Split(path1, "/") {
	// 	fmt.Println("\t", i, v)
	// }

	// fmt.Println("Spliting: ", path2)
	// for i, v := range strings.Split(path2, "/") {
	// 	fmt.Println("\t", i, v)
	// }

	// fmt.Println("\n==================\nSpliting: ", path)
	// for i, v := range urlPathProcessing(path) {
	// 	fmt.Println("\t", i, v)
	// }

	// fmt.Println("Spliting: ", path1)
	// for i, v := range urlPathProcessing(path1) {
	// 	fmt.Println("\t", i, v)
	// }

	// fmt.Println("Spliting: ", path2)
	// for i, v := range urlPathProcessing(path2) {
	// 	fmt.Println("\t", i, v)
	// }
	// path3 := "/"
	// fmt.Println("Spliting: ", path3)
	// for i, v := range urlPathProcessing(path3) {
	// 	fmt.Println("\t", i, v)
	// }

	testPassword()
}

func testPassword() {
	fmt.Println("Testing Passwords Hash")
	for {
		p1 := readPassword()
		p1str := hashAndSalt(p1)
		p2 := readPassword()
		match := comparePasswords(p1str, p2)
		fmt.Println(p1, p1str, p2, match)

	}
}

func readPassword() []byte {
	fmt.Println("Enter a password:")
	var pwd string
	n, err := fmt.Scan(&pwd)
	if err != nil {
		log.Println(err)
	}
	fmt.Println(pwd, n)
	return []byte(pwd)
}

func hashAndSalt(pwd []byte) string {
	cost := bcrypt.DefaultCost // 10
	hash, err := bcrypt.GenerateFromPassword(pwd, cost)
	if err != nil {
		log.Println(err)
	}
	return string(hash)
}

func comparePasswords(hashedPwd string, plainPwd []byte) bool {
	byteHash := []byte(hashedPwd)
	err := bcrypt.CompareHashAndPassword(byteHash, plainPwd)
	if err != nil {
		log.Println(err)
		return false
	}
	return true
}
